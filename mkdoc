#!/usr/bin/env perl

use Data::Dumper;
use Email::MIME;
use Encode qw/decode_utf8 encode_utf8/;
use HTML::Entities;
use IPC::Open2;

@sender_headers = ('From', 'Sender', 'X-Sender', 'Return-Path', 'Reply-To');
@recipient_headers = ('To', 'Cc', 'Delivered-To');


sub uniq
{
	return keys { map {$_=>undef} @_ };
}


for my $filepath (<STDIN>)
{
	chomp $filepath;
	my $rawmail;
	
	{
		open my $fh, '<', $filepath or die "$filepath: $!";
		local $/ = undef;
		$rawmail = <$fh>;
		close $fh;
	}
	my $email = Email::MIME->new($rawmail);
	
	
	my %attribute;
	
	$attribute{title} = encode_utf8(join "\n", $email->header('Subject'));
	$attribute{sender} = encode_utf8(join "\n", grep {$_} map {join "\n", $email->header($_)} @sender_headers);
	$attribute{recipient} = encode_utf8(join "\n", grep {$_} map {join "\n", $email->header($_)} @recipient_headers);
	
	@mime_parts = $email->subparts;
	if(@mime_parts == 0)
	{
		$attribute{content} = join "\n", $email->body;
	}
	else {
		for my $part (@mime_parts)
		{
			my ($mime_type) = $part->content_type =~ /^([^;]+)/;
			my $attachment_name = $part->filename;
			my @filter_cmd = ();
			
			if($attachment_name)
			{
				push @{$attribute{attachment}}, "$attachment_name $mime_type";
			}
			
			if($mime_type eq 'text/plain')
			{
				push @{$attribute{content}}, $part->body;
			}
			elsif($mime_type eq 'text/html')
			{
				my $html = $part->body;
				# a good enough html parser
				$html =~ s{<(style|script)\b.*?(</(?1)\b.*>)}{}gis;
				$html =~ s{</?(td|tr|th|form|br|hr|p)\b.*?>}{ }g;
				$html =~ s{<img[^>]*\balt=([^'"`]\S*|.[^'"`]*).*?>}{ $1 }g;
				$html =~ s{<table[^>]*\bsummary=([^'"`]\S*|.[^'"`]*).*?>}{ $1 }g;
				$html =~ s{<.*?>}{}g;
				$html = HTML::Entities::decode($html);
				$html =~ s/ +/ /g;
				push @{$attribute{content}}, $html;
			}
			elsif($mime_type =~ m{^(image|video)/})
			{ }
			elsif($mime_type eq 'application/pdf') {
				@filter_cmd = qw{pdftotext --strict-format - -};
			}
			elsif($mime_type eq 'application/rtf') {
				@filter_cmd = qw{unrtf --text /dev/stdin};
			}
			else
			{
				warn "$filepath: unsupported MIME attachment $mime_type\n";
			}
			
			if(@filter_cmd)
			{
				my $pid = open2(my $filter_out, my $filter_in, @filter_cmd);
				print {$filter_in} $part->body;
				close $filter_in;
				local $/ = undef;
				push @{$attribute{content}}, <$filter_out>;
				
				waitpid( $pid, 0 );
				my $child_exit_status = $? >> 8;
			}
		}
		
		$attribute{attachment} = encode_utf8( join "\n", @{$attribute{attachment}} ) if $attribute{attachment};
		$attribute{content} = join "\n", @{$attribute{content}} if $attribute{content};
	}
	
	
	
	print "location $_\n" for split /\n/, $filepath;
	for my $attr (keys %attribute)
	{
		print "$attr $_\n" for split /\n/, $attribute{$attr};
	}
	print "end\n";
}
